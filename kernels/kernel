#pragma OPENCL EXTENSION cl_khr_fp16 : enable

#define SAMPLE_ITERS 20

float square(float3 A, float3 B, float3 C, float3 D) {
    return (length(cross(B - A, C - A)) + length(cross(C - A, D - A))) / 2;
}

float DecodeShadow(float4 f) {
    return f.x;
}

float4 magicMult(float16 mat, float4 f) {
    return (float4)(mat.s0123 * f.x + mat.s4567 * f.y + mat.s89AB * f.z + mat.sCDEF * f.w);
}

float4 magicMultV2(float16 mat, float4 f) {
    float4 res = {dot(mat.s0123, f), dot(mat.s4567, f), dot(mat.s89AB, f), dot(mat.sCDEF, f)};
    return res;
}

__kernel void ComputeLightEmission(__global half* excident,
                                   __global float4* patchPoints,
                                   __global float16* glightMatrix,
                                   __global const float* lightParams,
                                   image2d_t shadowMap,
                                   __global half* reflection) {
	int i = get_global_id(0);
	float16 lightMatrix = *glightMatrix;
    float innerAngle = lightParams[0];
    float outterAngle = lightParams[1];
    float3 lightPosition = {lightParams[2], lightParams[3], lightParams[4]};
    float3 lightDirection = {lightParams[5], lightParams[6], lightParams[7]};

	float3 A = patchPoints[i * 6 + 0].xyz;
	float3 B = patchPoints[i * 6 + 1].xyz;
	float3 C = patchPoints[i * 6 + 2].xyz;
	float3 D = patchPoints[i * 6 + 5].xyz;

	float resultEmission = 0;

	sampler_t sampler = CLK_NORMALIZED_COORDS_TRUE | CLK_ADDRESS_CLAMP | CLK_FILTER_LINEAR;

	float3 AB = (B - A) / SAMPLE_ITERS;
	float3 AD = (D - A) / SAMPLE_ITERS;
	for (int j = 0; j <= SAMPLE_ITERS; ++j) {
        for (int h = 0; h <= SAMPLE_ITERS; ++h) {
			float3 point = A + j * AB + h * AD;
			float4 p4 = (float4){point.x, point.y, point.z, 1};
			float4 lightPoint = magicMultV2(lightMatrix, p4);
			float3 lightProj = lightPoint.xyz / lightPoint.w / 2 + (float3){0.5f, 0.5f, 0.5f};
			float depth = DecodeShadow(read_imagef(shadowMap, sampler, lightProj.xy));
			if (depth > lightProj.z - 0.000007f) {
                float currentAngle = dot(lightDirection, normalize(point - lightPosition));
                float angleImpact = clamp((outterAngle - currentAngle)
                                        / (outterAngle - innerAngle), 0.0f, 1.0f);
                resultEmission += angleImpact;
            }
        }
	}
	resultEmission /= (SAMPLE_ITERS + 1) * (SAMPLE_ITERS + 1);
	resultEmission *= square(A, B, C, D) * get_global_size(0) / 15;// * sqrt((float)get_global_size(0)) * 4;
    float4 resExc = resultEmission * vload_half4(i, reflection);
	vstore_half4(resExc, i, excident);
}

__kernel void FloatToHalfROBuffers(__global float* formFactors,
                                   __global half* halfFormFactors,
                                   __global int* matIndex,
                                   __global float4* matAmbient,
                                   __global half* halfReflection) {
    int i = get_global_id(0);
    vstore_half4(matAmbient[matIndex[i]], i, halfReflection);

    int j;
    int size = get_global_size(0);
    for (j = 0; j < size; ++j) {
        vstore_half(formFactors[i * size + j], i * size + j, halfFormFactors);
    }
}

__kernel void NullDeposit(__global half* deposit) {
    int i = get_global_id(0);
    //vstore_half4((float4){0.0f, 0.0f, 0.0f, 0.0f}, i, deposit);
}


__kernel void SendRays(__global half* excident,
                       __global half* ff,
                       __global half* reflection,
                       __global half* incident) {
    int i = get_global_id(0);
    int j;
    int size = get_global_size(0);
    float4 inc = {0.0f, 0.0f, 0.0f, 0.0f};
    float16 exc;
    float4 f;
    for (j = 0; j < size; j += 4) {
		int it = i * size + j;
		exc = vload_half16(j / 4, excident);
		f = vload_half4(it / 4, ff);
		inc += magicMult(exc, f);
    }
    inc = inc * vload_half4(i, reflection);
    for (j = 0; j < 6; ++j) {
        vstore_half4(inc, 6 * i + j, incident);
    }
}


__kernel void SendRaysV3(__global half* excident,
                       __global half* ff,
                       __global half* preincident) {
    int i = get_global_id(0);
    int i1 = get_global_id(1);
    int j;
    int size = get_global_size(0);
    float4 inc = {0.0f, 0.0f, 0.0f, 0.0f};
    float16 exc;
    float4 f;
    for (j = i1 * 16; j < min(size, (i1 + 1) * 16); j += 4) {
		int it = i * size + j;
		exc = vload_half16(j / 4, excident);
		f = vload_half4(it / 4, ff);
		inc += magicMult(exc, f);
    }
    vstore_half4(inc, i * get_global_size(1) + i1, preincident);
    /*if (i == 1) {
    printf("%d\n", i * get_global_size(1) + i1);
    }*/
}


__kernel void ReduceIncident(__global half* preincident, const int len) {
    int i = get_global_id(0);
    int j = get_global_id(1);
    int locsize = get_global_size(1);
    int index1 = i * len + j;
    int index2 = i * len + j + locsize;
    float4 val = vload_half4(index2, preincident);
    float4 val1 = vload_half4(index1, preincident);
    vstore_half4((float4){0, 0, 0, 0}, index2, preincident);
    vstore_half4(val + val1, index1, preincident);
}


__kernel void ReplaceIncident(__global half* preincident,
                              __global half* reflection,
                              __global half* incident,
                              const int len) {
    int i = get_global_id(0);
    float4 inc = vload_half4(i * len, preincident);
    inc += vload_half4(i * len + 1, preincident);
    inc *= vload_half4(i, reflection);
    for (int j = 0; j < 6; ++j) {
        vstore_half4(inc, 6 * i + j, incident);
    }
}


__kernel void SendRaysV2(__global half* excident,
                       __global half* ff,
                       __global half* reflection,
                       __global half* incident) {
    int i = get_global_id(0);
    int j;
    int size = get_global_size(0);
    float4 inc = {0.0f, 0.0f, 0.0f, 0.0f};
    float16 exc;
    float16 f;
    float4 f1, f2, f3, f4;
    for (j = 0; j < size; j += 16) {
		int it = i * size + j;
		f = vload_half16(it / 16, ff);
        f1 = f.s0123;
        f2 = f.s4567;
        f3 = f.s89AB;
        f4 = f.sCDEF;
        exc = vload_half16((j +  0) / 4, excident);
		inc += magicMult(exc, f1);
		exc = vload_half16((j +  4) / 4, excident);
		inc += magicMult(exc, f2);
		exc = vload_half16((j +  8) / 4, excident);
		inc += magicMult(exc, f3);
		exc = vload_half16((j + 12) / 4, excident);
		inc += magicMult(exc, f4);
    }
    inc = inc * vload_half4(i, reflection);
    for (j = 0; j < 6; ++j) {
        vstore_half4(inc, 6 * i + j, incident);
    }
}



__kernel void CollectLight(__global half* incident,
                           __global half* excident,
                           __global half* deposit) {
    int i = get_global_id(0);
    float4 inc = vload_half4(i, incident);
    vstore_half4(inc, i, excident);
    vstore_half4(inc + vload_half4(i, deposit), i, deposit);
}
